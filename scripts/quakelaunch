#!/usr/bin/env bash

thisdir=$(dirname $(readlink -f $0))

source "$thisdir"/quakelaunch.conf
quakedir=$(dirname "$quake")

# Going to use nocaseglob to do some case-insensitive file listing/matching.
shopt -s nocaseglob extglob

# Function to choose from a random set of error beeps and play it.
function beep {
  if [[ -n "$beep_player" && ${#beepsound[@]} -ne 0 ]]
  then
    "$beep_player" ${beepsound[$RANDOM % ${#beepsound[@]}]}
  fi
}

# Function to print a message. Then post it as a notification and/or beep.
function message {
  echo $1
  if [[ -n "$notification_icon" ]]
  then
    notify-send --icon="$notification_icon" "$1" --hint=string:desktop-entry:quake
  fi
  beep
}

# Function to print usage statement and beep.
function usage {
  message "usage: quakelaunch [archive|gamedir|foo.bsp|foo.quake]"
}

# Function to make sure the config has been populated with what we need to
# launch Quake.
function basic_validation {
  if [[ -z "$basedir" || -z "$quake" ]]
  then
    message "necessary option(s) in quakelaunch.conf have not been specified"
    exit 1
  fi
}

# Function to check consistency in other conf properties, after any gamedir-
# specific conf has been sourced.
function more_validation {
  if [[ $symlink_variant_names == "true" ]]
  then
    if [[ "$fix_capitalization" != "true" ]]
    then
      message "symlink_variant_names can only be enabled when fix_capitalization is also enabled"
      exit 1
    fi
  fi
}

# Take care of the simplest arguments cases:

# Forbid more than one arg.
if [[ -n "$2" ]]
then
  usage
  exit 1
fi

if [[ -n "$extra_quake_args" ]]
then
  extra_quake_args=""
  message "extra_quake_args in main conf ignored; should be used only in gamedir conf"
fi

# Simple launch if no args.
if [[ -z "$1" ]]
then
  basic_validation
  cd "$quakedir"
  exec "$quake" -basedir "$basedir" $quake_args
fi

# OK we have more complicated stuff to do! A few more utility functions:

# Function to see if the given dirs contain a (qw)progs.dat.
function is_standalone {
  paksfound=$(find -L "$@" -type f -iname '*.pak' 2>/dev/null)
  if [[ -n "$paksfound" ]]
  then
    if [[ $expak_installed == "true" ]]
    then
      paklist=$(echo "$paksfound" | sed 's/\(.*\)/"\1"/' | tr '\n' ' ' | sed 's/" "/","/g')
      progslist=$(python -c "import expak;print(' '.join([r for r in expak.resource_names([$paklist]) if r.lower().endswith('progs.dat')]))" 2>/dev/null)
      if [[ $? -eq 0 ]]
      then
        if [[ -n "$progslist" ]]
        then
          echo true
          return
        fi
        # Fall through to check for loose progs file.
      else
        # Didn't work. Since expak is supposedly installed let's complain.
        message "expak_installed=true in quakelaunch.conf, but failed to use expak"
        # Best guess, as per comment below.
        echo true
        return
      fi
    else
      # There are paks but we can't see what might be in there. For most new
      # releases this really does mean standalone, although for some older
      # Quoth releases (e.g. ne_tower) it might not. Just do best guess here.
      echo true
      return
    fi
  fi
  progsfound=$(find -L "$@" -type f -iname '*progs.dat' 2>/dev/null)
  if [[ -n "$progsfound" ]]
  then
    echo true
    return
  fi
  echo false
}

# Function to check if a gamedir exists and qualifies as "standalone".
function is_standalone_gamedir {
  checkdir="$1"
  if [[ -z "$userdata_home" ]]
  then
    is_standalone "$basedir"/"$checkdir"
  else
    is_standalone "$basedir"/"$checkdir" "$userdata_home"/"$checkdir"
  fi
}

# Function to check if a pattern is present in "document" files in a gamedir.
function docscheck {
  pattern="$1"
  checkdir="$2"
  if [[ -z "$userdata_home" ]]
  then
    grepdirs=( "$basedir"/"$checkdir" )
  else
    grepdirs=( "$basedir"/"$checkdir" "$userdata_home"/"$checkdir" )
  fi
  for dir in "${grepdirs[@]}"
  do
    if grep -qi -- "$pattern" "$dir"/*.txt "$dir"/*.htm* "$dir"/*readme* 2> /dev/null
    then
      echo true
      return
    fi
  done
  echo false
}

# Function to return a list of files (not dirs) with a given extension in gamedir.
function fileslist {
  extension="$1"
  checkdir="$2"
  if [[ -z "$userdata_home" ]]
  then
    ls -1dpL "$basedir"/"$checkdir"/*.$extension 2>/dev/null | grep -v '/$'
  else
    ls -1dpL "$basedir"/"$checkdir"/*.$extension "$userdata_home"/"$checkdir"/*.$extension 2>/dev/null | grep -v '/$'
  fi
}

# Function to force known-by-Quake subdirectories in cwd to lowercase.
# Defining knowndirs here for reference since it will also be used elsewhere.
# For simplicity the recap function just hardcodes the same set of dirs.
knowndirs="gfx locs maps music particles progs skins sound textures"
function recap_dirs {
  # Using match patterns of any kind here will force case-insensitive match
  # for the whole name (from the shopt -s nocaseglob).
  mv [Gg]fx gfx 2>/dev/null
  mv [Ll]ocs locs 2>/dev/null
  mv [Mm]aps maps 2>/dev/null
  mv [Mm]usic music 2>/dev/null
  mv [Pp]articles particles 2>/dev/null
  mv [Pp]rogs progs 2>/dev/null
  mv [Ss]kins skins 2>/dev/null
  mv [Ss]ound sound 2>/dev/null
  mv [Tt]extures textures 2>/dev/null
}

# Function to force some filenames (or just extensions) in cwd to lowercase.
# Quake assumes lowercase extensions for: pak/dem/sav/dat files, stuff in the
# maps dir, stuff in the locs dir, and stuff in the music dir. In the case of
# pak files and dat files we'll lowercase the whole name.
function recap_files {
  pakfiles=$(ls -1d *.pak *.dat 2>/dev/null)
  if [[ -n "$pakfiles" ]]
  then
    while IFS= read -r file
    do
      goodfile=$(echo $file | tr '[:upper:]' '[:lower:]')
      mv "$file" "$goodfile" 2>/dev/null
    done <<< "$pakfiles"
  fi
  extfiles=$(ls -1d *.dem *.sav locs/*.* maps/*.* music/*.* 2>/dev/null)
  if [[ -n "$extfiles" ]]
  then
    while IFS= read -r file
    do
      filebase=${file%.*}
      fileext=$(echo ${file##*.} | tr '[:upper:]' '[:lower:]')
      mv "$file" "$filebase".$fileext 2>/dev/null
    done <<< "$extfiles"
  fi
}

# Function to symlink common filename case variations to the actual file, for
# every loose file in the knowndirs subdirectories.
function create_symlinks {
  knowndirspat=${knowndirs// /\\|}
  curdir=$(readlink -f .)
  targetfiles=$(find "$curdir" -type f | exec grep "^$curdir/\($knowndirspat\)/")
  for file in $targetfiles
  do
    # Make all-lower, all-caps, and initial-caps variants.
    filedir=$(dirname -- "$file")
    filebase=$(basename -- "$file")
    all_lower=$(echo "$filebase" | tr '[:upper:]' '[:lower:]')
    all_upper=$(echo "$filebase" | tr '[:lower:]' '[:upper:]')
    init_caps="$(echo "${all_lower:0:1}" | tr '[:lower:]' '[:upper:]')${all_lower:1}"
    # Symlink all these to the original. Note that we expect some failures here
    # so swallow stderr.
    ln -s $file "$filedir/$all_lower" 2>/dev/null
    ln -s $file "$filedir/$all_upper" 2>/dev/null
    ln -s $file "$filedir/$init_caps" 2>/dev/null
  done
}

# XXX Note that this script doesn't always fix cases where filepaths baked
# into the bsp or quake.rc or etc. have the wrong capitalization compared to
# the actual files. We just blindly try to accomodate the most common errors.
# If some other filename case error happens, you will just need to catch that
# by watching the console for errors and fix it manually by renaming or making
# symlinks.

# Function to find the map that a savegame will load into.
function savemap {
  savegame="$1"
  i=0
  mapname=""
  while read line
  do
    i=$(expr $i + 1)
    if [[ "$i" == "20" ]]
    then
      mapname=$line
      break
    fi
  done < "$savegame"
  echo "$mapname"
}

# Function to generate the config to back up the jam_keybind for the given
# maplist input. If a second argument is specified it means that the given
# map is being loaded; if it matches a place in the jam aliases list then
# the jam key should be bound to the next map after that.
function jam_config {
  if [[ -z "$jam_keybind" ]]
  then
    echo ""
  else
    maplist="$1"
    loadmap="$2"
    startalias="alias jam jam_map_1"
    aliases=""
    i=1
    # Assuming there are no spaces in map names here; other things would break
    # too if there were.
    for map in $maplist
    do
      if [[ "$map" =~ start$ ]]
      then
        continue
      fi
      mapname=$(basename ${map%.*})
      j=$(expr $i + 1)
      aliases="$aliases"$'\n'"alias jam_map_$i \"alias jam jam_map_$j; map $mapname\""
      i=$j
      if [[ "$mapname" == "$loadmap" ]]
      then
        startalias="alias jam jam_map_$j"
      fi
    done
    if [[ -n "$aliases" ]]
    then
      echo "// Autogenerated by quakelaunch, feel free to delete this file"
      echo "bind $jam_keybind jam"
      echo "$startalias$aliases"
      echo "alias jam_map_$j \"echo All Done; play misc/talk.wav\""
    else
      echo ""
    fi
  fi
}

# Function to write the jam config into the given gamedir if appropriate, and
# return the Quake command line args to execute it. Second arg is maplist,
# optional third arg is a specific map being launched.
function jam_helper {
  dir="$1"
  maplist="$2"
  loadmap="$3"
  cfg=$(jam_config "$maplist" "$loadmap")
  if [[ -z "$cfg" ]]
  then
    echo ""
  else
    echo "$cfg" > "$dir"/jam_helper.cfg
    echo "+exec jam_helper.cfg"
  fi
}

# We have some target file or directory to process now.

arg="$1"
maplist=""
basegame_args=""
basegame_error=""
startmap=""
current_startmap=""
startmap_args=""
jamhelper=""
bsp=""

# First handle any ".quake" shortcut. This should change the argument into
# a directory.
if [[ -f "$arg" && "${arg##*.}" == "quake" ]]
then
  # If the file has content, treat that content as the arg. Otherwise we'll
  # derive the arg from current basedir and userdata settings.
  shortcut=$(cat "$arg")
  shortcut=${shortcut##+([[:space:]])}
  shortcut=${shortcut%%+([[:space:]])}
  if [[ -z "$shortcut" ]]
  then
    basic_validation
    arg=$(basename "$arg")
    if [[ -z "$userdata_home" || "$install_to_userdata" != "true" ]]
    then
      arg="$basedir"/"${arg%.*}"
    else
      arg="$userdata_home"/"${arg%.*}"
    fi
  else
    arg="$shortcut"
  fi
fi

# If the argument is still considered to be a file, we have some things to
# figure out before launch.
if [[ -f "$arg" ]]
then
  basic_validation
  # We don't do file case-fixing until we're sure we're in a gamedir (later),
  # so use case-insensitive match to check the extension here.
  if [[ "${arg##*.}" =~ ^bsp$ ]]
  then
    # It's a bsp file; climb up to find the gamedir. Then fall through into
    # the gamedir processing below, with a forced bsp.
    mapsdir=$(dirname "$arg")
    bsp=$(basename "$arg")
    arg=$(dirname "$mapsdir")
  else
    # Not a bsp. Let's see if we can open it as an archive.
    # First check for a qz extension. That is used to force default opening
    # of an archive with this script. If there's a qz extension we should
    # strip it and then proceed as normal.
    if [[ "${arg##*.}" =~ ^qz$ ]]
    then
      newarg="${arg%.*}"
      mv "$arg" "$newarg"
      if [[ $? -eq 0 ]]
      then
        arg="$newarg"
      else
        # This isn't necessarily a problem; it looks like aunpack doesn't
        # (usually?) depend on what the file extension is. So just keep going.
        # Send a warning notification tho.
        message "unable to rename .qz file, but trying to open it anyway"
      fi
    fi
    tmpdir=$(mktemp -d)
    aunpack -qX "$tmpdir" "$arg"
    if [[ $? -eq 0 ]]
    then
      chmod -R +w "$tmpdir"
    else
      chmod -R +w "$tmpdir"
      rm -rf "$tmpdir"
      if which aunpack >/dev/null
      then
        usage
      else
        message "aunpack utility not found; required to open archives"
      fi
      exit 1
    fi
    # Move the extracted contents to a new gamedir, named after the archive.
    destdir=$(basename "$arg")
    destdir=${destdir%.*}
    if [[ "$destdir" == "quoth2pt2full" ]]
    then
        # Special treatment for this Quoth release; it still needs to use the
        # directory name "quoth".
        destdir=quoth
    fi
    if [[ -z "$userdata_home" || "$install_to_userdata" != "true" ]]
    then
      destdir="$basedir"/"$destdir"
    else
      destdir="$userdata_home"/"$destdir"
    fi
    mv -T "$tmpdir" "$destdir"
    if [[ $? -ne 0 ]]
    then
      rm -rf $tmpdir
      if [[ -f "$destdir" ]]
      then
        message "$destdir already exists"
      else
        message "unable to create gamedir $destdir"
      fi
      exit 1
    fi
    # Take our best shot at making this playable.
    cd "$destdir"
    # Try to get rid of any extra directories generated in archive-creation,
    # as well as other files we don't want.
    while true
    do
      # Get rid of Windows stuff, config.cfg, and autoexec.cfg
      # Using match patterns with the config files to force case-insensitive
      # match for the whole name (from the shopt -s nocaseglob).
      rm -f *.exe *.dll *.bat *.cmd [Cc]onfig.cfg [Aa]utoexec.cfg
      # If pak or progs is here, assume everything is already organized and
      # we're done.
      paksprogs=$(ls -1d *.pak *progs.dat 2>/dev/null)
      if [[ -n "$paksprogs" ]]
      then
        break
      fi
      # If there is only one directory here, and it's not a known Quake
      # content directory, then it's packaging cruft. Move its contents up
      # and keep looping.
      dirshere=$(find -maxdepth 1 -type d | grep -v '^\.$')
      if [[ "$dirshere" != "" && $(echo "$dirshere" | wc -l) -eq 1 ]]
      then
        echo "$knowndirs" | grep -qwi "$dirshere"
        if [[ $? -ne 0 ]]
        then
          mv "$dirshere"/* .
          if [[ $? -ne 0 ]]
          then
            rm -rf "$destdir"
            message "failed in organizing the extracted archive contents"
            exit 1
          fi
          rm -rf "$dirshere"
          continue
        fi
      fi
      break
    done
    # If there are loose bsp/ent/lit/loc/map files in top level, put them in
    # their place. It is kind of weird for this to happen if there is a maps
    # or locs directory already, but if so I guess we'll just move them there.
    mapsfiles=$(ls -1d *.bsp *.ent *.lit *.map *.jmf *.rmf *.vmf 2>/dev/null)
    if [[ -n "$mapsfiles" ]]
    then
      mapsdir=$(ls -1d [Mm]aps 2>/dev/null)
      if [[ "$mapsdir" == "" ]]
      then
        mkdir maps
        mapsdir=maps
      else
        if [[ $(echo "$mapsdir" | wc -l) -ne 1 ]]
        then
          rm -rf "$destdir"
          message "archive contains multiple maps dirs"
          exit 1
        fi
      fi
      # Assuming there are no spaces in map names here; other things would
      # break too if there were.
      mv $mapsfiles $mapsdir
    fi
    locsfiles=$(ls -1d *.loc 2>/dev/null)
    if [[ -n "$locsfiles" ]]
    then
      locsdir=$(ls -1d [Ll]ocs 2>/dev/null)
      if [[ "$locsdir" == "" ]]
      then
        mkdir locs
        locsdir=locs
      else
        if [[ $(echo "$locsdir" | wc -l) -ne 1 ]]
        then
          rm -rf "$destdir"
          message "archive contains multiple locs dirs"
          exit 1
        fi
      fi
      # Assuming there are no spaces in loc names here; other things would
      # break too if there were.
      mv $locsfiles $locsdir
    fi
    # Tidy up.
    if [[ $cleanup_archive == "true" ]]
    then
      rm -f "$arg"
    fi
    # See if we can make a shortcut (if enabled).
    if [[ -n "$shortcuts_dir" ]]
    then
      mod=$(basename "$destdir")
      tmpfile=$(mktemp)
      echo -n "$destdir" > $tmpfile
      mkdir -p "$shortcuts_dir"
      mv "$tmpfile" "$shortcuts_dir"/"$mod".quake
      if [[ $? -ne 0 ]]
      then
        rm -rf $destdir
        rm -f $tmpfile
        if [[ ! -d "$shortcuts_dir" ]]
        then
          message "shortcuts dir $shortcuts_dir does not exist"
        else
          if [[ -f "$destdir" ]]
          then
            message "shortcut for $mod already exists"
          else
            message "unable to create shortcut for $mod"
          fi
        fi
        # Don't bail out at this point... we don't have a shortcut, it's not
        # the end of the world.
      fi
    fi
    # Fall through into the gamedir processing below.
    arg="$destdir"
  fi
fi

# Done with any file examination and archive processing. Now figure out how to
# launch Quake.

# At this point we'd like the argument to be a directory, presumably a gamedir.
# We may have created this with the code above, or it may have been created
# outside of this script.
if [[ -d "$arg" ]]
then
  gamedir="$arg"
  gamedirparent=$(dirname "$gamedir")
  mod=$(basename "$gamedir")
  # Before we make any further decisions, do an initial source of any
  # quakelaunch.conf in the targeted directory to see if it has redefined
  # basedir or userdata_home.
  if [[ -f "$gamedir"/quakelaunch.conf ]]
  then
    source "$gamedir"/quakelaunch.conf
  fi
  basic_validation
  more_validation
  # If this directory is not under basedir or (if relevant) userdata_home, we
  # can't deal with it.
  if [[ "$gamedirparent" != "$basedir" ]]
  then
    if [[ -z "$userdata_home" ]]
    then
      message "target directory is not within the Quake basedir \"$basedir\""
      exit 1
    fi
    if [[ "$gamedirparent" != "$userdata_home" ]]
    then
      message "target directory is not within the Quake basedir \"$basedir\" or userdata_home \"$userdata_home\""
      exit 1
    fi
  fi
  # Now handle the override of all other quakelaunch.conf stuff. This will
  # probably involve re-sourcing the conf we already sourced above, but that's
  # fine... helps us make sure we've sourced things in the right order.
  calc_basegame_args=true
  calc_maplist=true
  calc_startmap=true
  has_conf=false
  has_superconf=false
  if [[ -n "$userdata_home" ]]
  then
    mkdir -p "$userdata_home"/"$mod"
    conf="$userdata_home"/"$mod"/quakelaunch.conf
    # If we're using a userdata_home but there is also a quakelaunch.conf in
    # the subdirectory of basedir, we can't ignore it. We'll source it first
    # and then override it with any conf from userdata.
    superconf="$basedir"/"$mod"/quakelaunch.conf
    if [[ -f "$superconf" ]]
    then
      has_superconf=true
      source "$superconf"
    fi
  else
    conf="$basedir"/"$mod"/quakelaunch.conf
  fi
  tempconf="$conf".$$
  if [[ -f "$conf" ]]
  then
    has_conf=true
    source "$conf"
  fi
  basic_validation
  more_validation
  # Everything has been sourced. For certain overrides, note that we should
  # NOT try to calculate values for these vars below.
  if [[ $has_conf == "true" || $has_superconf == "true" ]]
  then
    # basegame_args could be set to anything, including empty.
    if [[ $has_superconf == "true" ]]
    then
      if grep -q -- "^\s*basegame_args=" "$superconf"
      then
        calc_basegame_args=false
      fi
    fi
    if [[ $has_conf == "true" ]]
    then
      if grep -q -- "^\s*basegame_args=" "$conf"
      then
        calc_basegame_args=false
      fi
    fi
    # maplist and startmap only make sense to set to nonempty values.
    if [[ "$maplist" != "" ]]
    then
      calc_maplist=false
    fi
    if [[ "$startmap" != "" ]]
    then
      calc_startmap=false
    fi
    # If there's an existing config (not "superconf"), make sure that
    # preview_readme_and_config, fix_capitalization, and symlink_variant_names
    # will be false on future launches.
    if [[ $has_conf == "true" ]]
    then
      if [[ "$preview_readme_and_config" != "false" ]]
      then
        grep -v -- "^\s*preview_readme_and_config=" "$conf" > "$tempconf"
        echo "preview_readme_and_config=false" >> "$tempconf"
        mv -f "$tempconf" "$conf"
      fi
      if [[ "$fix_capitalization" != "false" ]]
      then
        grep -v -- "^\s*fix_capitalization=" "$conf" > "$tempconf"
        echo "fix_capitalization=false" >> "$tempconf"
        mv -f "$tempconf" "$conf"
      fi
      if [[ "$symlink_variant_names" != "false" ]]
      then
        grep -v -- "^\s*symlink_variant_names=" "$conf" > "$tempconf"
        echo "symlink_variant_names=false" >> "$tempconf"
        mv -f "$tempconf" "$conf"
      fi
    fi
  fi
  # Take care of any obvious capitalization gotchas.
  if [[ $fix_capitalization == "true" ]]
  then
    if [[ -d "$basedir"/"$mod" ]]
    then
      pushd "$basedir"/"$mod" > /dev/null
      recap_dirs
      recap_files
      popd > /dev/null
    fi
    if [[ -n "$userdata_home" ]]
    then
      if [[ -d "$userdata_home"/"$mod" ]]
      then
        pushd "$userdata_home"/"$mod" > /dev/null
        recap_dirs
        recap_files
        popd > /dev/null
      fi
    fi
  fi
  if [[ $symlink_variant_names == "true" ]]
  then
    if [[ -d "$basedir"/"$mod" ]]
    then
      pushd "$basedir"/"$mod" > /dev/null
      create_symlinks
      popd > /dev/null
    fi
    if [[ -n "$userdata_home" ]]
    then
      if [[ -d "$userdata_home"/"$mod" ]]
      then
        pushd "$userdata_home"/"$mod" > /dev/null
        create_symlinks
        popd > /dev/null
      fi
    fi
  fi
  # For a non-standalone mod where basegame_args was not explicitly set in a
  # gamedir-specific conf, see if we can figure out any required basegame from
  # grepping docs. Arcane Dimensions is somewhat different; we assume AD if
  # and only if a bsp has the "ad_" prefix, as that works for every existing
  # map currently. (Note that we don't have to worry about maps inside pak files
  # since this logic only applies to non-standalone releases.)
  if [[ $calc_basegame_args == "true" && $(is_standalone_gamedir "$mod") == "false" ]]
  then
    ad_bsps=$(ls -1d "$basedir"/"$mod"/maps/ad_*.bsp 2>/dev/null)
    if [[ -n "$ad_bsps" ]]
    then
      if [[ -n "$ad_basegame_args" ]]
      then
        basegame_args=$ad_basegame_args
      else
        basegame_error="ad"
      fi
    else
      if [[ $(docscheck "quoth" "$mod") == "true" ]]
      then
        basegame_args=-quoth
      else
        if [[ $(docscheck "-hipnotic\|-game hipnotic" "$mod") == "true" ]]
        then
          basegame_args=-hipnotic
        else
          if [[ $(docscheck "-rogue\|-game rogue" "$mod") == "true" ]]
          then
            basegame_args=-rogue
          else
            if [[ $(docscheck "copper" "$mod") == "true" ]]
            then
              if [[ -n "$copper_basegame_args" ]]
              then
                basegame_args=$copper_basegame_args
              else
                basegame_error="copper"
              fi
            fi
          fi
        fi
      fi
    fi
  fi
  # If maplist was not explicitly set in a gamedir-specific conf, build it now.
  if [[ $calc_maplist == "true" ]]
  then
    # First see if we can look for maps inside any pak files.
    valid_maplist=true
    if [[ -z "$userdata_home" ]]
    then
      paks=$(ls -1d "$basedir"/"$mod"/*.pak 2>/dev/null)
    else
      paks=$(ls -1d "$basedir"/"$mod"/*.pak "$userdata_home"/"$mod"/*.pak 2>/dev/null)
    fi
    if [[ -n "$paks" ]]
    then
      # If the Python module expak is installed, use that to list maps inside
      # the paks.
      if [[ $expak_installed == "true" ]]
      then
        paklist=$(echo "$paks" | sed 's/\(.*\)/"\1"/' | tr '\n' ' ' | sed 's/" "/","/g')
        maplist=$(python -c "import expak;print(' '.join([r for r in expak.resource_names([$paklist]) if r.lower().startswith('maps/') and r.lower().endswith('.bsp')]))" 2>/dev/null)
        if [[ $? -ne 0 ]]
        then
          # Didn't work. Since expak is supposedly installed let's complain.
          message "expak_installed=true in quakelaunch.conf, but failed to use expak"
          valid_maplist=false
        fi
      else
        # There are paks but we can't see what maps might be in there.
        valid_maplist=false
      fi
    fi
    # If we haven't given up on maplist-building, now look for loose bsp files
    # and add those to our list. Make sure we skip any symlinks.
    if [[ "$valid_maplist" == "true" ]]
    then
      if [[ -z "$userdata_home" ]]
      then
        loosemaps=$(find "$basedir"/"$mod"/maps -maxdepth 1 -type f -name '*.bsp' 2>/dev/null | sed "s/.*maps\//maps\//" | tr '\n' ' ')
      else
        loosemaps=$(find "$basedir"/"$mod"/maps "$userdata_home"/"$mod"/maps -maxdepth 1 -type f -name '*.bsp' 2>/dev/null | sed "s/.*maps\//maps\//" | tr '\n' ' ')
      fi
      if [[ -n "$loosemaps" ]]
      then
        # Assuming there are no spaces in map names here; other things would
        # break too if there were.
        maplist="$maplist $loosemaps"
      fi
      # Remove things that look like bmodels; remove "maps/" prefix and .bsp
      # extension; sort alphabetically; remove any leading/trailing spaces.
      maplist=$(echo "$maplist" | sed 's/ *maps\/b_[^ ]*\.bsp */ /gI' | sed 's/ *maps\/[^\/ ]*\/[^ ]*\.bsp */ /gI' | sed 's/maps\/\([^ ]*\)\.bsp/\1/gI' | tr ' ' '\n' | sort -f | uniq | tr '\n' ' ')
      maplist=${maplist##+([[:space:]])}
      maplist=${maplist%%+([[:space:]])}
    fi
  else
      # If we got maplist from the gamedir config, just trust it.
      valid_maplist=true
  fi
  # If startmap was not explicitly set in a gamedir-specific conf, determine
  # it now. We may or may not use this for launch (e.g. not if loading a
  # savegame) but we may still want to write it into the config.
  if [[ $calc_startmap == "true" && "$valid_maplist" == "true" ]]
  then
    # If there's only one map, that's our huckleberry.
    if [[ $(echo "$maplist" | wc -w) -eq 1 ]]
    then
      startmap="$maplist"
    else
      # More than one map. Is there a start map? Use it if so. Note for
      # this comparison we slap a leading/trailing space back onto the
      # list so we can easily do a complete-word match for "start".
      if [[ " $maplist " =~ " start " ]]
      then
        # Need to be careful to use the right capitalization.
        startmap=$(echo " $maplist " | sed 's/.* \(start\) .*/\1/I')
      else
        # It's possible there's some other map that ends in "start", like
        # "acstart". Use THAT if it exists.
        if [[ "$maplist " =~ "start " ]]
        then
          startmap=$(echo " $maplist " | sed 's/.* \([^ ]*start\)\ .*/\1/I')
        fi
      fi
    fi
    # There's some other heuristics we could use here buuuuut we risk
    # skipping past the actual first map and causing confusion. So no more
    # cleverness. We can just load the mod without a startmap and let the
    # user manually load a map.
  fi
  # If we're loading a savegame or a specific bsp, we know what map we will
  # load into (regardless of what the normal "startmap" is).
  if [[ -n "$bsp" ]]
  then
    current_startmap="${bsp%.*}"
    startmap_args="+map \"$current_startmap\""
  else
    if [[ -z "$userdata_home" ]]
    then
      lastsave=$(ls -1dt "$basedir"/"$mod"/*.sav 2>/dev/null | head -1)
    else
      # When userdata_home is set, savegames under the basedir are ignored.
      lastsave=$(ls -1dt "$userdata_home"/"$mod"/*.sav 2>/dev/null | head -1)
    fi
    if [[ -n "$lastsave" ]]
    then
      current_startmap=$(savemap "$lastsave")
      startmap_args="+load \"$(basename ${lastsave%.*})\""
    fi
  fi
  # Save our calculated args if necessary.
  conf_created=false
  if [[ $has_conf == "false" ]]
  then
    echo "#* You are creating: \"$conf\"" > "$tempconf"
    echo "#*" >> "$tempconf"
    if [[ $has_superconf == "true" ]]
    then
      echo "#* WARNING, a conf file also exists at: \"$superconf\"" >> "$tempconf"
      echo "#*" >> "$tempconf"
    fi
    cat <<- EOF >> "$tempconf"
	# The basegame_args option is a list of Quake arguments used to set a base
	# gamedir or missionpack... such as -quoth or -hipnotic. The quakelaunch
	# script has put its best guess here, but you can change it. If you don't want
	# any such arguments then set it to an empty value. If you want to specify
	# multiple arguments, enclose the list of arguments in doublequotes.
	EOF
    echo >> "$tempconf"
    echo "basegame_args=\"$basegame_args\"" >> "$tempconf"
    echo >> "$tempconf"
    if [[ $basegame_error != "" ]]
    then
      if [[ $basegame_error == "ad" ]]
      then
        cat <<- EOF >> "$tempconf"
	# Gamedir contains a doc that mentions Arcane Dimensions. It's unclear how
	# to launch this since ad_basegame_args is undefined in quakelaunch.conf.
	# You may need to manually merge the contents of this gamedir into your
	# Arcane Dimensions gamedir, and then launch Arcane Dimensions.
	EOF
      fi
      if [[ $basegame_error == "copper" ]]
      then
        cat <<- EOF >> "$tempconf"
	# Gamedir contains a doc that mentions Copper. It's unclear how to launch
	# this since copper_basegame_args is undefined in quakelaunch.conf.
	# You may need to manually merge the contents of this gamedir into your
	# Copper gamedir, and then launch Copper.
	EOF
      fi
      cat <<- EOF >> "$tempconf"
	# If you think it's OK for quakelaunch to launch this gamedir (maybe because
	# you have fixed some things) then you can remove the line below that is
	# setting basegame_error.
	EOF
      echo >> "$tempconf"
      echo "basegame_error=\"$basegame_error\"" >> "$tempconf"
    fi
    echo >> "$tempconf"
    echo >> "$tempconf"
    cat <<- EOF >> "$tempconf"
	# You can set and override other options in this file too!

	#* The startmap option is the map name (without the .bsp extension) that will
	#* be launched into when no specific map is forced (by a savegame existing or
	#* by double-clicking a bsp file). If it is set to an emptystring value then
	#* no map will initially be loaded in that case.

	#* The maplist option is the list of all singleplayer maps that can/should be
	#* playable in this gamedir. It will be used to find a startmap (if startmap
	#* is not explicitly set in this file) and to build the mapjam helper keybinds.

	#* If startmap and/or maplist are not set in this file, quakelaunch will
	#* recalculate them each time you play this gamedir. That recalculation might
	#* be handy if you will be adding/removing maps in this gamedir. On the other
	#* hand you may want to explicitly set values for them here to fix a problem.

	#* As examples, the commented-out lines below show the values for startmap and
	#* maplist that the quakelaunch script has currently calculated:
	EOF
    echo >> "$tempconf"
    echo "# startmap=\"$startmap\"" >> "$tempconf"
    echo >> "$tempconf"
    echo "# maplist=\"$maplist\"" >> "$tempconf"
    echo >> "$tempconf"
    echo >> "$tempconf"
    cat <<- EOF >> "$tempconf"
	#* Other options that might be useful to set in this file include quake (the
	#* path to the Quake executable to use), quake_args (command-line arguments
	#* to REPLACE any specified in the main config), and extra_quake_args
	#* (command-line arguments to ADD TO any specified in the main config).
	#* For example you could set uncomment the extra_quake_args line below and
	#* modify it to have a value of "-listen 16" if this gamedir is a bots mod
	#* that must run as a listen server.
	EOF
    echo >> "$tempconf"
    echo "# extra_quake_args=\"\"" >> "$tempconf"
    echo >> "$tempconf"
    cat <<- EOF >> "$tempconf"
	#* The commented-out line below shows the current value of quake_args as
	#* set by the main config, just FYI:
	EOF
    echo >> "$tempconf"
    echo "# quake_args=\"$quake_args\"" >> "$tempconf"
    mv -f "$tempconf" "$conf"
    conf_created=true
  fi
  # Start the readme viewer(s) and config editor.
  if [[ $preview_readme_and_config == "true" ]]
  then
    if [[ -z "$config_editor" ]]
    then
      message "the config_editor option in quakelaunch.conf must be set when preview_readme_and_config is true"
      exit 1
    fi
    # Spawn readme viewer(s) as necessary.
    if [[ -n "$txt_viewer" ]]
    then
      txtfiles=$(fileslist "txt" "$mod")
      if [[ -n "$txtfiles" ]]
      then
        while IFS= read -r file
        do
          (($txt_viewer "$file")&)
        done <<< "$txtfiles"
      fi
      pushd "$basedir"/"$mod" > /dev/null
      readmefiles=$(ls -1dpL !(*.*) 2>/dev/null | grep -v '/$' | grep -i readme)
      popd > /dev/null
      if [[ -n "$readmefiles" ]]
      then
        while IFS= read -r file
        do
          (($txt_viewer "$basedir"/"$mod"/"$file")&)
        done <<< "$readmefiles"
      fi
    fi
    if [[ -n "$html_viewer" ]]
    then
      htmlfiles=$(fileslist "htm*" "$mod")
      if [[ -n "$htmlfiles" ]]
      then
        while IFS= read -r file
        do
          (($html_viewer "$file")&)
        done <<< "$htmlfiles"
      fi
    fi
    if [[ -n "$doc_viewer" ]]
    then
      docfiles=$(fileslist "doc" "$mod")
      if [[ -n "$docfiles" ]]
      then
        while IFS= read -r file
        do
          (($doc_viewer "$file")&)
        done <<< "$docfiles"
      fi
    fi
    if [[ -n "$pdf_viewer" ]]
    then
      pdffiles=$(fileslist "pdf" "$mod")
      if [[ -n "$pdffiles" ]]
      then
        while IFS= read -r file
        do
          (($pdf_viewer "$file")&)
        done <<< "$pdffiles"
      fi
    fi
    if [[ -n "$md_viewer" ]]
    then
      mdfiles=$(fileslist "md" "$mod")
      if [[ -n "$mdfiles" ]]
      then
        while IFS= read -r file
        do
          (($md_viewer "$file")&)
        done <<< "$mdfiles"
      fi
    fi
    $config_editor "$conf"
    basegame_error=""
    source "$conf"
    basic_validation
    more_validation
  fi
  # If we just created this config, clean it up a bit by removing examples
  # and then initialize the preview_readme_and_config and fix_capitalization
  # values to false.
  if [[ $conf_created == "true" ]]
  then
    grep -v -- "^#\*" "$conf" | grep -v -- "^\s*#\s*startmap=" | grep -v -- "^\s*#\s*maplist=" | grep -v -- "^\s*#\s*extra_quake_args=" | grep -v -- "^\s*#\s*quake_args=" | sed 'N;/^\n$/D;P;D;' > "$tempconf"
    echo >> "$tempconf"
    cat <<- EOF >> "$tempconf"
	# The options below are set false after initial launch so they won't
	# happen again on future launches (unless you manually set them back to
	# true).
	EOF
    echo >> "$tempconf"
    echo "preview_readme_and_config=false" >> "$tempconf"
    echo "fix_capitalization=false" >> "$tempconf"
    mv -f "$tempconf" "$conf"
  fi
  # Abandon ship now if basegame_error is still set.
  if [[ $basegame_error != "" ]]
  then
    if [[ $basegame_error == "ad" ]]
    then
      message "Gamedir contains a doc that mentions Arcane Dimensions. It's unclear how to launch this since ad_basegame_args is undefined in quakelaunch.conf."
      exit 1
    fi
    if [[ $basegame_error == "copper" ]]
    then
      message "Gamedir contains a doc that mentions Copper. It's unclear how to launch this since copper_basegame_args is undefined in quakelaunch.conf."
      exit 1
    fi
  fi
  # Check to see if any required base gamedirs are missing.
  if [[ "$basegame_args" == "-quoth" ]]
  then
    if [[ $(is_standalone_gamedir "quoth") == "false" ]]
    then
      message "depends on quoth gamedir but quoth is not installed"
      exit 1
    fi
  else
    if [[ "$basegame_args" == "-hipnotic" ]]
    then
      if [[ $(is_standalone_gamedir "hipnotic") == "false" ]]
      then
        message "depends on hipnotic gamedir but hipnotic is not installed"
        exit 1
      fi
    else
      if [[ "$basegame_args" == "-rogue" ]]
      then
        if [[ $(is_standalone_gamedir "rogue") == "false" ]]
        then
          message "depends on rogue gamedir but rogue is not installed"
          exit 1
        fi
      else
        if [[ -n "$ad_basegame_args" && "$basegame_args" == "$ad_basegame_args" ]]
        then
          if [[ -n "$ad_gamedir" && $(is_standalone_gamedir "$ad_gamedir") == "false" ]]
          then
            message "depends on $ad_gamedir gamedir but $ad_gamedir is not installed"
            exit 1
          fi
        else
          if [[ -n "$copper_basegame_args" && "$basegame_args" == "$copper_basegame_args" ]]
          then
            if [[ -n "$copper_gamedir" && $(is_standalone_gamedir "$copper_gamedir") == "false" ]]
            then
              message "depends on $copper_gamedir gamedir but $copper_gamedir is not installed"
              exit 1
            fi
          fi
        fi
      fi
    fi
  fi
  # Let's run some Quake!
  cd "$quakedir"
  if [[ -n "$startmap" && -z "$current_startmap" ]]
  then
    current_startmap="$startmap"
    startmap_args="+map \"$current_startmap\""
  fi
  if [[ "$valid_maplist" == "true" ]]
  then
    if [[ -z "$userdata_home" ]]
    then
      jamhelper=$(jam_helper "$basedir"/"$mod" "$maplist" "$current_startmap")
    else
      jamhelper=$(jam_helper "$userdata_home"/"$mod" "$maplist" "$current_startmap")
    fi
  fi
  exec "$quake" -basedir "$basedir" $quake_args $extra_quake_args $basegame_args -game "$mod" $startmap_args $jamhelper
fi

# If we got here, we couldn't figure out what to do.
usage
exit 1
