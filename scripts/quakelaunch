#!/usr/bin/env bash

thisdir=$(dirname $(readlink -f $0))

source "$thisdir"/quakelaunch.conf
quakedir=$(dirname "$quake")

# Going to use nocaseglob to do some case-insensitive file listing/matching.
shopt -s nocaseglob extglob

# Choose from a random set of error beeps and play it.
function beep {
  if [[ -n "$beep_player" && ${#beepsound[@]} -ne 0 ]]
  then
    "$beep_player" ${beepsound[$RANDOM % ${#beepsound[@]}]}
  fi
}

# Print a message. Then post it as a notification and/or beep.
function message {
  echo $1
  if [[ -n "$notification_icon" ]]
  then
    notify-send --icon="$notification_icon" "$1" --hint=string:desktop-entry:quake
  fi
  beep
}

# Print usage statement and beep.
function usage {
  message "usage: quakelaunch [archive|gamedir|foo.bsp|foo.quake]"
}

# Make sure the config has been populated.
if [[ -z "$basedir" || -z "$quake" ]]
then
  message "necessary option(s) in quakelaunch.conf have not been specified"
  exit 1
fi

# Take care of the simplest arguments cases:

# Forbid more than one arg.
if [[ -n "$2" ]]
then
  usage
  exit 1
fi

# Simple launch if no args.
if [[ -z "$1" ]]
then
  cd "$quakedir"
  exec "$quake" -basedir "$basedir"
fi

# OK we have more complicated stuff to do! A few more utility functions:

# Function to see if the cwd is in a gamedir with a pak file or (qw)progs.dat.
function is_standalone {
  # XXX If expak is installed we could grope the paks to see if they contain
  # a progs.dat. However it would generally be really odd for a release to have
  # a pak file at all if it's intended to be dropped into some other mod, so
  # that's probably not necessary.
  paksfound=$(find . -type f -iname '*.pak')
  if [[ -n "$paksfound" ]]
  then
    echo true
    return
  fi
  progsfound=$(find . -type f -iname '*progs.dat')
  if [[ -n "$progsfound" ]]
  then
    echo true
    return
  fi
  echo false
}

# Function to force known-by-Quake subdirectories to lowercase.
# Defining knowndirs here for reference since it will also be used elsewhere.
# For simplicity the recap function just hardcodes the same set of dirs.
knowndirs="gfx locs maps music particles progs skins sound textures"
function recap_dirs {
  # Using match patterns of any kind here will force case-insensitive match
  # for the whole name (from the shopt -s nocaseglob).
  mv [Gg]fx gfx 2>/dev/null
  mv [Ll]ocs locs 2>/dev/null
  mv [Mm]aps maps 2>/dev/null
  mv [Mm]usic music 2>/dev/null
  mv [Pp]articles particles 2>/dev/null
  mv [Pp]rogs progs 2>/dev/null
  mv [Ss]kins skins 2>/dev/null
  mv [Ss]ound sound 2>/dev/null
  mv [Tt]extures textures 2>/dev/null
}

# Function to force some filenames (or just extensions) to lowercase. Quake
# assumes lowercase extensions for: pak/dem/sav/dat files, stuff in the maps dir,
# stuff in the locs dir, and stuff in the music dir. In the case of pak files
# and dat files we'll lowercase the whole name.
function recap_files {
  pakfiles=$(ls -1d *.pak *.dat 2>/dev/null)
  for file in $pakfiles
  do
    goodfile=$(echo $file | tr '[:upper:]' '[:lower:]')
    mv "$file" "$goodfile" 2>/dev/null
  done
  extfiles=$(ls -1d *.dem *.sav locs/*.* maps/*.* music/*.* 2>/dev/null)
  for file in $extfiles
  do
    filebase=${file%.*}
    fileext=$(echo ${file##*.} | tr '[:upper:]' '[:lower:]')
    mv "$file" "$filebase".$fileext 2>/dev/null
  done
}

# XXX Note that this script doesn't (and can't easily) fix cases where
# filepaths baked into the bsp or quake.rc or etc. have the wrong
# capitalization compared to the actual files. In that case you kind of just
# have to watch the console for errors and fix manually by renaming or making
# symlinks.

# Function to find the map that a savegame will load into.
function savemap {
  savegame="$1"
  i=0
  mapname=""
  while read line
  do
    i=$(expr $i + 1)
    if [[ "$i" == "20" ]]
    then
      mapname=$line
      break
    fi
  done < "$savegame"
  echo "$mapname"
}

# Function to generate the config to back up the jam_keybind for the given
# maplist input. If a second argument is specified it means that the given
# map is being loaded; if it matches a place in the jam aliases list then
# the jam key should be bound to the next map after that.
function jam_config {
  if [[ -z "$jam_keybind" ]]
  then
    echo ""
  else
    maplist="$1"
    loadmap="$2"
    startalias="alias jam jam_map_1"
    aliases=""
    i=1
    for map in $maplist
    do
      if [[ "$map" =~ start$ ]]
      then
        continue
      fi
      mapname=$(basename ${map%.*})
      j=$(expr $i + 1)
      aliases="$aliases"$'\n'"alias jam_map_$i \"alias jam jam_map_$j; map $mapname\""
      i=$j
      if [[ "$mapname" == "$loadmap" ]]
      then
        startalias="alias jam jam_map_$j"
      fi
    done
    if [[ -n "$aliases" ]]
    then
      echo "// Autogenerated by quakelaunch, feel free to delete this file"
      echo "bind $jam_keybind jam"
      echo "$startalias$aliases"
      echo "alias jam_map_$j \"echo All Done; play misc/talk.wav\""
    else
      echo ""
    fi
  fi
}

# Function to write the jam config into the given gamedir if appropriate, and
# return the Quake command line args to execute it. Second arg is maplist,
# optional third arg is a specific map being launched.
function jam_helper {
  gamedir="$1"
  maplist="$2"
  loadmap="$3"
  cfg=$(jam_config "$maplist" "$loadmap")
  if [[ -z "$cfg" ]]
  then
    echo ""
  else
    echo "$cfg" > "$gamedir"/jam_helper.cfg
    echo "+exec jam_helper.cfg"
  fi
}

# We have some target file or directory to process now.

arg="$1"
maplist=""
basegame_args=""
startmap=""
current_startmap=""
startmap_args=""
jamhelper=""
bsp=""

# First handle any ".quake" shortcut.
if [[ -f "$arg" && "${arg##*.}" == "quake" ]]
then
  # If the file has content, treat that content as the arg. Otherwise treat
  # $basedir/$argbasename as the arg.
  shortcut=$(cat "$arg")
  shortcut=${shortcut##+([[:space:]])}
  shortcut=${shortcut%%+([[:space:]])}
  if [[ -z "$shortcut" ]]
  then
    arg=$(basename "$arg")
    arg="$basedir"/"${arg%.*}"
  else
    arg="$shortcut"
  fi
fi

# If the argument is a file, we have some things to figure out before launch.
if [[ -f "$arg" ]]
then
  # We don't do file case-fixing until we're sure we're in a gamedir (later),
  # so use case-insensitive match to check the extension here.
  if [[ "${arg##*.}" =~ ^bsp$ ]]
  then
    # It's a bsp file; climb up to find the gamedir. Then fall through into
    # the gamedir processing below, with a forced bsp.
    mapsdir=$(dirname "$arg")
    bsp=$(basename "$arg")
    arg=$(dirname "$mapsdir")
  else
    # Not a bsp. Let's see if we can open it as an archive.
    # First check for a qz extension. That is used to force default opening
    # of an archive with this script. If there's a qz extension we should
    # strip it and then proceed as normal.
    if [[ "${arg##*.}" =~ ^qz$ ]]
    then
      newarg="${arg%.*}"
      mv "$arg" "$newarg"
      if [[ $? -eq 0 ]]
      then
        arg="$newarg"
      else
        # This isn't necessarily a problem; it looks like aunpack doesn't
        # (usually?) depend on what the file extension is. So just keep going.
        # Send a warning notification tho.
        message "unable to rename .qz file, but trying to open it anyway"
      fi
    fi
    tmpdir=$(mktemp -d)
    aunpack -qX "$tmpdir" "$arg"
    if [[ $? -ne 0 ]]
    then
      rm -rf "$tmpdir"
      if which aunpack >/dev/null
      then
        usage
      else
        message "aunpack utility not found; required to open archives"
      fi
      exit 1
    fi
    cd "$tmpdir"
    # If readme mentions Copper or Arcane Dimensions, it's not clear how
    # we should install this, unless it is itself a standalone mod.
    # Exception if we have defined the ability to use copper/ad as a basegame.
    if [[ -z "$ad_basegame_args" ]]
    then
      # Also match singular "Arcane Dimension" since some folks call it that.
      ad_found=$(find . -type f \( -iname '*.txt' -o -iname '*.htm*' -o -iname '*readme*' \) -exec grep -i "arcane dimension" {} \;)
      if [[ -n "$ad_found" && $(is_standalone) == "false" ]]
      then
        rm -rf "$tmpdir"
        message "Archive contains a text file that mentions Arcane Dimensions. It's not clear how to auto-install this, so bailing out."
        exit 1
      fi
    fi
    if [[ -z "$copper_basegame_args" ]]
    then
      copper_found=$(find . -type f \( -iname '*.txt' -o -iname '*.htm*' -o -iname '*readme*' \) -exec grep -i copper {} \;)
      if [[ -n "$copper_found" && $(is_standalone) == "false" ]]
      then
        rm -rf "$tmpdir"
        message "Archive contains a text file that mentions Copper. It's not clear how to auto-install this, so bailing out."
        exit 1
      fi
    fi
    # Move the extracted contents to a new gamedir, named after the archive.
    destdir=$(basename "$arg")
    destdir=${destdir%%.*}
    if [[ "$destdir" == "quoth2pt2full" ]]
    then
        # Special treatment for this Quoth release; it still needs to use the
        # directory name "quoth".
        destdir=quoth
    fi
    destdir="$basedir"/"$destdir"
    mv -T "$tmpdir" "$destdir"
    if [[ $? -ne 0 ]]
    then
      rm -rf $tmpdir
      if [[ -f "$destdir" ]]
      then
        message "$destdir already exists"
      else
        message "unable to create gamedir $destdir"
      fi
      exit 1
    fi
    # Take our best shot at making this playable.
    cd "$destdir"
    # Try to get rid of any extra directories generated in archive-creation,
    # as well as other files we don't want.
    while true
    do
      # Get rid of Windows stuff, config.cfg, and autoexec.cfg
      # Using match patterns with the config files to force case-insensitive
      # match for the whole name (from the shopt -s nocaseglob).
      rm -f *.exe *.dll [Cc]onfig.cfg [Aa]utoexec.cfg
      # If there is only one directory here, and it's not a known Quake
      # content directory, then it's packaging cruft. Move its contents up
      # and keep looping.
      dirshere=$(find -maxdepth 1 -type d | grep -v '^\.$')
      if [[ "$dirshere" != "" && $(echo "$dirshere" | wc -l) -eq 1 ]]
      then
        echo "$knowndirs" | grep -qwi "$dirshere"
        if [[ $? -ne 0 ]]
        then
          mv "$dirshere"/* .
          if [[ $? -ne 0 ]]
          then
            rm -rf "$destdir"
            message "failed in organizing the extracted archive contents"
            exit 1
          fi
          rm -rf "$dirshere"
          continue
        fi
      fi
      break
    done
    # If there are loose bsp/ent/lit/loc/map files in top level, put them in
    # their place. It is kind of weird for this to happen if there is a maps
    # or locs directory already, but if so I guess we'll just move them there.
    mapsfiles=$(ls -1d *.bsp *.ent *.lit *.map 2>/dev/null)
    if [[ -n "$mapsfiles" ]]
    then
      mapsdir=$(ls -1d [Mm]aps 2>/dev/null)
      if [[ "$mapsdir" == "" ]]
      then
        mkdir maps
        mapsdir=maps
      else
        if [[ $(echo "$mapsdir" | wc -l) -ne 1 ]]
        then
          rm -rf "$destdir"
          message "archive contains multiple maps dirs"
          exit 1
        fi
      fi
      mv $mapsfiles $mapsdir
    fi
    locsfiles=$(ls -1d *.loc 2>/dev/null)
    if [[ -n "$locsfiles" ]]
    then
      locsdir=$(ls -1d [Ll]ocs 2>/dev/null)
      if [[ "$locsdir" == "" ]]
      then
        mkdir locs
        locsdir=locs
      else
        if [[ $(echo "$locsdir" | wc -l) -ne 1 ]]
        then
          rm -rf "$destdir"
          message "archive contains multiple locs dirs"
          exit 1
        fi
      fi
      mv $locsfiles $locsdir
    fi
    # Tidy up.
    if [[ $cleanup_archive == "true" ]]
    then
      rm -f "$arg"
    fi
    # See if we can make a shortcut (if enabled).
    if [[ -n "$shortcuts_dir" ]]
    then
      mod=$(basename "$destdir")
      tmpfile=$(mktemp)
      echo -n "$destdir" > $tmpfile
      mkdir -p "$shortcuts_dir"
      mv "$tmpfile" "$shortcuts_dir"/"$mod".quake
      if [[ $? -ne 0 ]]
      then
        rm -rf $destdir
        rm -f $tmpfile
        if [[ ! -d "$shortcuts_dir" ]]
        then
          message "shortcuts dir $shortcuts_dir does not exist"
        else
          if [[ -f "$destdir" ]]
          then
            message "shortcut for $mod already exists"
          else
            message "unable to create shortcut for $mod"
          fi
        fi
        # Don't bail out at this point... we don't have a shortcut, it's not
        # the end of the world.
      fi
    fi
    # Fall through into the gamedir processing below.
    arg="$destdir"
  fi
fi

# Done with any file examination and archive processing. Now figure out how to
# launch Quake.

# At this point we'd like the argument to be a directory, presumably a gamedir.
# We may have created this with the code above, or it may have been created
# outside of this script.
if [[ -d "$arg" ]]
then
  tempconf=./quakelaunch.conf.$$
  gamedir="$arg"
  gamedirparent=$(dirname "$gamedir")
  # Allow running gamedirs outside the normal basedir if it looks like a
  # valid Quake install.
  if [[ ! -d "$gamedirparent"/id1 ]]
  then
    message "target directory is not inside a Quake installation"
    exit 1
  fi
  basedir="$gamedirparent"
  mod=$(basename "$gamedir")
  cd "$gamedir"
  # Allow gamedir-specific override of quakelaunch.conf stuff.
  calc_basegame_args=true
  calc_maplist=true
  calc_startmap=true
  if [[ -f ./quakelaunch.conf ]]
  then
    # Pick up any variable overrides.
    source ./quakelaunch.conf
    # For certain overrides, note that we should NOT try to calculate values
    # for these vars below.
    # basegame_args could be set to anything, including empty.
    if grep -q -- "^\s*basegame_args=" ./quakelaunch.conf
    then
      calc_basegame_args=false
    fi
    # maplist and startmap only make sense to set to nonempty values.
    if [[ "$maplist" != "" ]]
    then
      calc_maplist=false
      valid_maplist=true
    fi
    if [[ "$startmap" != "" ]]
    then
      calc_startmap=false
      startmap_args="+map \"$startmap\""
    fi
    # Make preview_readme_and_config be false on future launches.
    if [[ "$preview_readme_and_config" != "false" ]]
    then
      grep -v -- "^\s*preview_readme_and_config=" ./quakelaunch.conf > "$tempconf"
      echo "preview_readme_and_config=false" >> "$tempconf"
      mv -f "$tempconf" ./quakelaunch.conf
    fi
  fi
  # Take care of any obvious capitalization gotchas.
  if [[ $fix_capitalization == "true" ]]
  then
    recap_dirs
    recap_files
  fi
  # If basegame_args was not explicitly set in a gamedir-specific conf, see if
  # we can figure out any required basegame from grepping docs.
  if [[ $calc_basegame_args == "true" ]]
  then
    if grep -qi -- "quoth" *.txt *.htm* *readme* 2> /dev/null
    then
      if [[ -d "$basedir"/quoth ]]
      then
        basegame_args=-quoth
      else
        message "requires quoth basegame but quoth is not installed"
        exit 1
      fi
    else
      if grep -qi -- "-hipnotic\|-game hipnotic" *.txt *.htm* *readme* 2> /dev/null
      then
        if [[ -d "$basedir"/hipnotic ]]
        then
          basegame_args=-hipnotic
        else
          message "requires hipnotic basegame but hipnotic is not installed"
          exit 1
        fi
      else
        if grep -qi -- "-rogue\|-game rogue" *.txt *.htm* *readme* 2> /dev/null
        then
          if [[ -d "$basedir"/rogue ]]
          then
            basegame_args=-rogue
          else
            message "requires rogue basegame but rogue is not installed"
            exit 1
          fi
        else
          if [[ -n "$ad_basegame_args" ]] && grep -qi "arcane dimension" *.txt *.htm* *readme* 2> /dev/null
          then
            if [[ $(is_standalone) == "false" ]]
            then
              if [[ -z "$ad_gamedir" || -d "$basedir"/"$ad_gamedir" ]]
              then
                basegame_args=$ad_basegame_args
              else
                message "requires $ad_gamedir basegame but $ad_gamedir is not installed"
                exit 1
              fi
            fi
          else
            if [[ -n "$copper_basegame_args" ]] && grep -qi "copper" *.txt *.htm* *readme* 2> /dev/null
            then
              if [[ $(is_standalone) == "false" ]]
              then
                if [[ -z "$copper_gamedir" || -d "$basedir"/"$copper_gamedir" ]]
                then
                  basegame_args=$copper_basegame_args
                else
                  message "requires $copper_gamedir basegame but $copper_gamedir is not installed"
                  exit 1
                fi
              fi
            fi
          fi
        fi
      fi
    fi
  fi
  # If maplist was not explicitly set in a gamedir-specific conf, build it now.
  if [[ $calc_maplist == "true" ]]
  then
    # First see if we can look for maps inside any pak files.
    valid_maplist=true
    paks=$(ls -1d *.pak 2>/dev/null | tr '\n' ' ')
    if [[ -n "$paks" ]]
    then
      # If the Python module expak is installed, use that to list maps inside
      # the paks.
      if [[ $expak_installed == "true" ]]
      then
        paklist=$(echo $paks | sed 's/ /", "/g' | sed 's/\(.*\)/"\1"/')
        maplist=$(python -c "import expak;print(' '.join([r for r in expak.resource_names([$paklist]) if r.lower().startswith('maps/')]))" 2>/dev/null)
        if [[ $? -ne 0 ]]
        then
          # Didn't work. Since expak is supposedly installed let's complain.
          message "expak_installed=true in quakelaunch.conf, but failed to use expak"
          valid_maplist=false
        fi
      else
        # There are paks but we can't see what maps might be in there.
        valid_maplist=false
      fi
    fi
    # If we haven't given up on maplist-building, now look for loose bsp files
    # and add those to our list.
    if [[ "$valid_maplist" == "true" ]]
    then
      loosemaps=$(ls -1d maps/*.bsp 2>/dev/null | tr '\n' ' ')
      if [[ -n "$loosemaps" ]]
      then
        maplist="$maplist $loosemaps"
      fi
      # Remove things that look like bmodels; remove "maps/" prefix and .bsp
      # extension; sort alphabetically; remove any leading/trailing spaces.
      maplist=$(echo "$maplist" | sed 's/ *maps\/b_[^ ]*\.bsp */ /gI' | sed 's/maps\/\([^ ]*\)\.bsp/\1/gI' | tr ' ' '\n' | sort -f | tr '\n' ' ')
      maplist=${maplist##+([[:space:]])}
      maplist=${maplist%%+([[:space:]])}
    fi
  fi
  # If startmap was not explicitly set in a gamedir-specific conf, determine
  # it now. We may or may not use this for launch (e.g. not if loading a
  # savegame) but we may still want to write it into the config.
  if [[ $calc_startmap == "true" && "$valid_maplist" == "true" ]]
  then
    # If there's only one map, that's our huckleberry.
    if [[ $(echo "$maplist" | wc -w) -eq 1 ]]
    then
      startmap="$maplist"
    else
      # More than one map. Is there a start map? Use it if so. Note for
      # this comparison we slap a leading/trailing space back onto the
      # list so we can easily do a complete-word match for "start".
      if [[ " $maplist " =~ " start " ]]
      then
        # Need to be careful to use the right capitalization.
        startmap=$(echo " $maplist " | sed 's/.* \(start\) .*/\1/I')
      else
        # It's possible there's some other map that ends in "start", like
        # "acstart". Use THAT if it exists.
        if [[ "$maplist " =~ "start " ]]
        then
          startmap=$(echo " $maplist " | sed 's/.* \([^ ]*start\)\ .*/\1/I')
        fi
      fi
    fi
    # There's some other heuristics we could use here buuuuut we risk
    # skipping past the actual first map and causing confusion. So no more
    # cleverness. We can just load the mod without a startmap and let the
    # user manually load a map.
  fi
  # If we're loading a savegame or a specific bsp, we know what map we will
  # load into (regardless of what the normal "startmap" is).
  if [[ -n "$bsp" ]]
  then
    current_startmap="${bsp%.*}"
    startmap_args="+map \"$current_startmap\""
  else
    lastsave=$(ls -1dt *.sav 2>/dev/null | head -1)
    if [[ -n "$lastsave" ]]
    then
      current_startmap=$(savemap "$basedir/$mod/$lastsave")
      startmap_args="+load \"${lastsave%.*}\""
    fi
  fi
  # Save our calculated args if necessary.
  conf_created=false
  if [[ ! -f ./quakelaunch.conf ]]
  then
    cat <<- EOF > "$tempconf"
	# The basegame_args option is a list of Quake arguments used to set a base
	# gamedir or missionpack... such as -quoth or -hipnotic. The quakelaunch
	# script has put its best guess here, but you can change it. If you don't want
	# any such arguments then set it to an empty value. If you want to specify
	# multiple arguments, enclose the list of arguments in doublequotes.
	EOF
    echo >> "$tempconf"
    echo "basegame_args=\"$basegame_args\"" >> "$tempconf"
    echo >> "$tempconf"
    echo >> "$tempconf"
    cat <<- EOF >> "$tempconf"
	#* You can set and override other options in this file too!

	#* The startmap option is the map name (without the .bsp extension) that will
	#* be launched into when no specific map is forced (by a savegame existing or
	#* by double-clicking a bsp file). If it is set to an emptystring value then
	#* no map will initially be loaded in that case.

	#* The maplist option is the list of all singleplayer maps that can/should be
	#* playable in this gamedir. It will be used to find a startmap (if startmap
	#* is not explicitly set in this file) and to build the mapjam helper keybinds.

	#* If startmap and/or maplist are not set in this file, quakelaunch will
	#* recalculate them each time you play this gamedir. That recalculation might
	#* be handy if you will be adding/removing maps in this gamedir. On the other
	#* hand you may want to explicitly set values for them here to fix a problem.

	#* As examples, the commented-out lines below show the values for startmap and
	#* maplist that the quakelaunch script has currently calculated:
	EOF
    echo >> "$tempconf"
    echo "# startmap=\"$startmap\"" >> "$tempconf"
    echo >> "$tempconf"
    echo "# maplist=\"$maplist\"" >> "$tempconf"
    echo >> "$tempconf"
    echo >> "$tempconf"
    cat <<- EOF >> "$tempconf"
	#* Other options that might be useful to set in this file include quake (the
	#* path to the Quake executable to use) and quake_args (any other command-line
	#* arguments). For example you could set quake_args to a value of "-listen 16"
	#* if this gamedir is a bots mod that must run as a listen server.
	EOF
    mv -f "$tempconf" ./quakelaunch.conf
    conf_created=true
  fi
  # Start the readme viewer(s) and config editor.
  if [[ $preview_readme_and_config == "true" ]]
  then
    if [[ -z "$config_editor" ]]
    then
      message "the config_editor option in quakelaunch.conf must be set when preview_readme_and_config is true"
      exit 1
    fi
    # Spawn readme viewer(s) as necessary.
    if [[ -n "$txt_viewer" ]]
    then
      for txtfile in $(ls -1d *.txt 2>/dev/null)
      do
        (($txt_viewer $txtfile)&)
      done
      for readmefile in $(ls -1d !(*.*) 2>/dev/null | grep -i readme)
      do
        (($txt_viewer $readmefile)&)
      done
    fi
    if [[ -n "$html_viewer" ]]
    then
      for htmlfile in $(ls -1d *.htm* 2>/dev/null)
      do
        (($html_viewer $htmlfile)&)
      done
    fi
    if [[ -n "$doc_viewer" ]]
    then
      for docfile in $(ls -1d *.doc 2>/dev/null)
      do
        (($doc_viewer $docfile)&)
      done
    fi
    if [[ -n "$pdf_viewer" ]]
    then
      for pdffile in $(ls -1d *.pdf 2>/dev/null)
      do
        (($pdf_viewer $pdffile)&)
      done
    fi
    $config_editor ./quakelaunch.conf
    source ./quakelaunch.conf
  fi
  # If we just created this config, clean it up a bit by removing examples
  # and then initialize the preview_readme_and_config value to false.
  if [[ $conf_created == "true" ]]
  then
    grep -v -- "^#\*" ./quakelaunch.conf | grep -v -- "^\s*#\s*startmap=" | grep -v -- "^\s*#\s*maplist=" | sed 'N;/^\n$/D;P;D;' > "$tempconf"
    cat <<- EOF >> "$tempconf"
	# The preview_readme_and_config option is set false after initial launch so
	# that the readme and config editor(s) won't appear on future launches.
	EOF
    echo >> "$tempconf"
    echo "preview_readme_and_config=false" >> "$tempconf"
    mv -f "$tempconf" ./quakelaunch.conf
  fi
  # Let's run some Quake!
  cd "$quakedir"
  if [[ -n "$startmap" && -z "$current_startmap" ]]
  then
    current_startmap="$startmap"
    startmap_args="+map \"$current_startmap\""
  fi
  if [[ "$valid_maplist" == "true" ]]
  then
    jamhelper=$(jam_helper "$basedir/$mod" "$maplist" "$current_startmap")
  fi
  exec "$quake" -basedir "$basedir" $quake_args $basegame_args -game "$mod" $startmap_args $jamhelper
fi

# If we got here, we couldn't figure out what to do.
usage
exit 1
